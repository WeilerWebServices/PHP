<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 325489 Maintainer: seros Status: ready -->
<!-- Reviewed: no -->

<chapter xml:id="mysqlnd-qc.quickstart" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Guia rápida y ejemplos</title>
 <para>
  El complemento de caché de consultas de mysqlnd es fácil de usar.
  Esta guía rápida muestra los casos de uso típicos y proporciona consejos prácticos
  para poder empezar a usarlo.
 </para>
 <para>
  Se recomienda encarecidamente leer las secciones de referencia además de esta
  guía rápida. Es seguro comenzar con esta guía.
  Sin embargo, antes de usar el complemento en entornos de misiones críticas,
  se urge que se lea además la información de fondo de las
  secciones de referencia.
 </para>
 <para>
  La mayoría de los ejemplos usan la extensión <link linkend="ref.mysqli">mysqli</link>,
  ya que es la extensión de MySQL para PHP más completa. Sin embargo, el complemento
  se puede usar con cualesquiera de las extensiones de MySQL para PHP que utilicen la
  biblioteca <link linkend="book.mysqlnd">mysqlnd</link>.
 </para>
 
 <section xml:id="mysqlnd-qc.quickstart.concepts" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Arquitectura y conceptos</title>
  <para>
   El complemento de caché de consultas está implementado como una extensión de PHP.
   Está escrita en C y opera bajo el manto de PHP. Durante el
   arraque del intérprete de PHP, se registra como un complemento de
   <link linkend="book.mysqlnd">mysqlnd</link> para reemplazar a los métodos
   en C de mysqlnd seleccionados. Por lo tanto, se puede cambiar el comportamiento de cualquier
   extensión de MySQL para PHP (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>,
   <link linkend="ref.mysql">mysql</link>) compilada para usar la
   biblioteca mysqlnd sin cambiar la API de la extensión. Esto hace que
   el complemento sea compatible con cada una de las aplicaciones de MySQL para PHP.
   Ya que las APIs existentes no se cambian, es casi transparente
   de usar. Por favor, véase la
   <link linkend="mysqlnd.plugin">descripción de la API de complementos de mysqlnd</link>
   para una discusión sobre las ventajas de la arquitectura del complemento y
   una comparación con soluciones basadas en proxy.
  </para>
  <para>
   <emphasis role="bold">Transparente de usar</emphasis>
  </para>
  <para>
   En tiempo de ejecución de PHP, PECL/mysqlnd_qc puede representar a consultas enviadas desde PHP
   (<link linkend="book.mysqlnd">mysqlnd</link>) al servidor MySQL.
   Luego inspecciona la sentencia para buscar si puede almacenar en caché
   sus resultados. Si puede, el conjunto de resultados se almacena en caché usando un gestor de
   almacenamiento, por lo que ejecuciones posteriores de la sentencia se servirán desde la caché por
   un periodo definido por el usuario. El tiempo de vida (TTL) de una entrada de la caché
   se puede establecer globalmente o en función de cada sentencia.
  </para>
  <para>
   Una sentencia será almacena en caché si al complemento se le indica que almacene todas
   las sentencias globalmente, o si la consulta comienza con la sugerencia SQL
   (<literal>/*qc=on*/</literal>). El complemento puede almacenar en caché cualquier
   consulta emitida invocando a las llamadas apropiadas a la API de cualquier extensión existente
   de MySQL para PHP.
  </para>
  <para>
   <emphasis role="bold">Almacenamiento flexible: distintos gestores de almacenamiento</emphasis>
  </para>
  <para>
   Se admiten distintos gestores de almacenamiento para ofrecer diferentes ámbitos para las entradas
   de la caché. Los diferentes ámbitos tienen en cuenta diferentes grados de compartir las
   entradas de la caché entre clientes.
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>default</literal> (interno): memoria del proceso, ámbito: proceso, una o más peticiones web dependiendo del modelo de desarrollo de PHP usado
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>APC</literal>: memoria compartida, ámbito: servidor único, múltiples peticiones web
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>SQLite</literal>: memoria o fichero, ámbito: servidor único, múltiples peticiones web
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>MEMCACHE</literal>: memoria principal, ámbito: servidor único o varios, múltiples peticiones web
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>user</literal> (interno): definido por el usuario - cualquiera, ámbito: definido por el usuario - cualquiera
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   El soporte para los gestores de almacenamiento <literal>APC</literal>, <literal>SQLite</literal>
   y <literal>MEMCACHE</literal> ha de estar habilitado en tiempo de compilación. Los gestores
   <literal>default</literal> y <literal>user</literal> son internos. Es posible
   intercambiar entre gestores de almacenamiento compilados en función a cada consulta en tiempo de ejecución.
   Sin embargo, se recomienda elegir un gestor de almacenamiento y usarlo para todas las entradas de la caché.
  </para>
  <para>
   <emphasis role="bold">Defensa de cierre interna para evitar la sobrecarga</emphasis>
  </para>
  <para>
   Para evitar situaciones de sobrecarga, el complemento de caché posee un mecanismo de defensa de cierre interna.
   Si una entrada de la caché expira, muchos cliente que usen las entradas de la caché intentarán
   refrescar dicha entrada. Durante el refresco, muchos clientes podrían acceder
   al servidor de bases de datos de forma concurrente. En el peor caso, el servidor de bases de datos
   se sobrecargará y le llevará cada vez más tiempo refrescar la entradas de la caché, las cuales,
   de una en una, permiten que más y más clientes intenten refrescar dichas entradas. Para evitar
   que ocurra esto, el complemento posee un mecanismo de defensa de cierre interna. Si se habilita dicha
   defensa y el complemento detecta que una entrada de la caché ha expirado, ampliará el tiempo de vida
   de dicha entrada antes de refrescar las entradas de la caché. De esta manera, otros accesos
   concurrentes a la entrada de la caché expirada aún los sirve la caché por un cierto
   tiempo. Los demás accesos concurrentes no desencadenan un refresco concurrente. Lo ideal sería
   que las entradas de la caché fueran refrescadas por el cliente, el cual ampliaría el periodo de vida de las entradas
   de la caché antes de que otros clientes intenten refrescar la caché y ocasionar potencialmente
   una situación de sobrecarga.
  </para>
  <para>
   <emphasis role="bold">Enfoque único para el almacenamiento en caché</emphasis>
  </para>
  <para>
   PECL/mysqlnd_qc posee un enfoque único para almacenar en caché conjuntos de resultados que es superior
   al de las soluciones de caché basadas en aplicaciones. Éstas primero introducen
   un conjunto de resultados en variables de PHP. Luego, dichas variables son serializadas para
   el almacenamiento en una caché persistente, y luego deserializadas cuando se obtienen. La caché
   de consultas de mysqlnd almacena los datos sin tratar del protocolo de conexión enviados desde MySQL a PHP
   en su caché y los reproduce, si aún son válidos, para una búsqueda coincidente en la caché. De esta forma se ahorra un paso extra
   de serialización ya que todas las soluciones basadas en aplicaciones deben hacerlo.
   Puede almacenar los datos sin tratar del protocolo de conexión en la caché sin tener que
   serializarlos primero para una variable de PHP y deserializar dicha variable para almacenarlos
   de nuevo en la caché.
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.quickstart.configuration">
  <title>Puesta en marcha</title>
  <para>
   El complemento está imlementado como una extensión de PHP. Véanse también las
   <link linkend="mysqlnd-qc.installation">instrucciones de instalación</link> para
   instalar la extensión
   <link xlink:href="&url.pecl.package;mysqlnd_qc">PECL/mysqlnd_qc</link>.
  </para>
  <para>
   Se ha de compilar o configurar la extensión (<link linkend="ref.mysqli">mysqli</link>,
   <link linkend="ref.pdo-mysql">PDO_MYSQL</link>,
   <link linkend="ref.mysql">mysql</link>) que se planee utilizar con soporte para
   la biblioteca <link linkend="book.mysqlnd">mysqlnd</link>. PECL/mysqlnd_qc
   es un complemento para la biblioteca mysqlnd. Para usar el complemento con cualquier extensión de MySQL
   para PHP existente (APIs), la extensión ha de utilizar la biblioteca mysqlnd.
  </para>
  <para>
   Luego, se ha de cargar la extensión en PHP y activar el complemento en el fichero de configuración
   de PHP usando la directiva de configuración de PHP llamada
   <link linkend="ini.mysqlnd-qc.enable-qc">mysqlnd_qc.enable_qc</link>.
  </para>
  <para>
   <example>
    <title>Habilitar el complemento (php.ini)</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
]]>
    </programlisting>
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.quickstart.caching">
  <title>Almacenar consultas en la caché</title>
  <para>
   Hay cuatro maneras de desencadenar el almacenamiento en caché de una consulta.
   <itemizedlist>
    <listitem>
     <simpara>Usar sugerencias SQL en función de cada consulta</simpara>
    </listitem>
    <listitem>
     <simpara>
      Llamadas de retorno porporcionadas por el usuario para decidir en función de cada consulta, por ejemplo, usando <function>mysqlnd_qc_is_select</function>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <function>mysqlnd_set_cache_condition</function> para reglas basadas en decisiones automáticas en cada consulta
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default = 1</link></literal>
      para almacenar en caché todas las consultas a ciegas
     </simpara>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   El uso de las sugerencias SQL y de
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default = 1</link></literal>
   se expilca más abajo. Por vafor, consulte la referenca de la función
   <function>mysqlnd_qc_is_select</function> para una descripción del uso de una llamada de retorno, y de
   <function>mysqlnd_qc_set_cache_condition</function> sobre cómo establecer reglas para el almacenamiento
   automático en caché.
  </para>
  <para>
   Una sugerencia SQL es un comentario que sigue los
   estándares. Como comentario de SQL, es ignorado por la base de datos. Una consulta es considerada
   candidata para su almacenamiento en caché si comienza con la sugerencia SQL que habilita dicho almacenamiento
   o si es una sentencia <literal>SELECT</literal>.
  </para>
  <para>
   Una consulta individual que debiera ser almacenada debe comenzar con la sugerencia SQL
   <literal>/*qc=on*/</literal>. Se recomienda usar la constante de PHP
   <literal><link linkend="mysqlnd-qc.constants">MYSQLND_QC_ENABLE_SWITCH</link></literal>
   en lugar del valor de cadena.
  </para>
  <para>
   <itemizedlist>
    <listitem>
     <para>
      no candidata para su almacenamiento en caché y no almacenada: <literal>INSERT INTO test(id) VALUES (1)</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      no candidata para su almacenamiento en caché y no almacenada: <literal>SHOW ENGINES</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      candidata para su almacenamiento en caché pero no almacenada: <literal>SELECT id FROM test</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      candidata para su almacenamiento y almacenada: <literal>/*qc=on*/SELECT id FROM test</literal>
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <para>
   Las sentencias <literal>SELECT</literal> del ejemplo están prefijadas con la sugerencia SQL
   <literal><link linkend="mysqlnd-qc.constants">MYSQLND_QC_ENABLE_SWITCH</link></literal>
   para habilitar su almacenamiento en caché. La sugerencia SQL debe colocarse al
   comienzo de la cadena de consulta para habilitar el almacenamiento en caché.
  </para>
  <para>
   <example>
    <title>Usar la sugerencia SQL <literal>MYSQLND_QC_ENABLE_SWITCH</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Conectar, crear y rellenar la tabla test */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

/* Será almacenada en caché debido a la sugerencia SQL */
$inicio = microtime(true);
$res   = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 1");

var_dump($res->fetch_assoc());
$res->free();

printf("Tiempo total de consulta no almacenada: %.6fs\n", microtime(true) - $inicio);

/* Coincidencia con la caché */
$inicio = microtime(true);
$res   = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 1");

var_dump($res->fetch_assoc());
$res->free();

printf("Tiempo total de consulta almacenada: %.6fs\n", microtime(true) - $inicio);
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
array(1) {
  ["id"]=>
  string(1) "1"
}
Tiempo total de consulta no almacenada: 0.000740s
array(1) {
  ["id"]=>
  string(1) "1"
}
Tiempo total de consulta almacenada: 0.000098s
]]>
    </screen>
   </example>
  </para>
  <para>
   Si no se configura nada más, como es el caso del ejemplo de esta guía rápida,
   el complemento usará en gestor de almacenamiento interno <literal>default</literal>.
   El gestor de almacenamiento <literal>default</literal> utiliza la memoria del proceso para mantener una entrada de la caché.
   Dependiendo del modelo de desarrollo de PHP, un proceso de PHP podría servir una o más
   peticiones web. Por favor, consulte el manual del servidor web para más detalles.
   Los detalles son irrelevantes para los ejemplos dados en esta guía rápida.
  </para>
  <para>
   El complemento de caché de consultas almacenará todas las consultas sin considerar si
   la cadena de consulta comienza con la sugerencia SQL que habilita dicho almacenamiento,
   si la directiva de configuración de PHP
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default</link></literal>
   está establecida a <literal>1</literal>. El ajuste
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default</link></literal>
   es evaluado por el núcleo del complemento de caché de consultas.
   Ni el gestor de almacenamiento interno ni uno definido por el usuario pueden sobrescribir el ajuste.
  </para>
  <para>
   La sugerencia SQL <literal>/*qc=off*/</literal> se puede usar para deshabilitar el almacenamiento en caché
   de consultas individuales si
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default = 1</link></literal>.
   Se recomienda usar la constante de PHP
   <literal><link linkend="mysqlnd-qc.constants">MYSQLND_QC_DISABLE_SWITCH</link></literal>
   en lugar del valor de cadena.
  </para>
  <para>
   <example>
    <title>Usar la sugerencia SQL <literal>MYSQLND_QC_DISABLE_SWITCH</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.cache_by_default=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Conectar, crear y rellenar la tabla test */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

/* Será almacenada aunque no esté presente ninguna sugerencia SQL ya que mysqlnd_qc.cache_by_default = 1*/
$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

$mysqli->query("DELETE FROM test WHERE id = 1");

/* Coincidencia con la caché - ¡sin invalidación automática y aún válida! */
$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

/* No coincide con la caché - la consulta no debe almacenarse debido a la sugerencia SQL */
$res = $mysqli->query("/*" . MYSQLND_QC_DISABLE_SWITCH . "*/SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(1) {
  ["id"]=>
  string(1) "1"
}
array(1) {
  ["id"]=>
  string(1) "1"
}
NULL
]]>
    </screen>
   </example>
  </para>
  <para>
   PECL/mysqlnd_qc prohíbe el almacenamiento en la caché de sentencias donde al menos una columna del conjunto
   de resultados de dichas sentencias no muestren el nombre de la tabla en sus metadatos de forma predeterminada.
   Éste normalmente es el caso para las columnas originadas desde funciones SQL tales como
   <literal>NOW()</literal> o <literal>LAST_INSERT_ID()</literal>. La política
   se dirige a prevenir fallos si se usa el almacenamiento por omisión.
  </para>
  <para>
   <example>
    <title>Ejemplo que muestra qué tipos de sentencias no son almacenadas en la caché</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.cache_by_default=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Conectar, crear y rellenar la tabla test */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1)");

for ($i = 0; $i < 3; $i++) {

    $inicio = microtime(true);

    /* Nota: la sentencia no será almacenada debido al uso de NOW() */
    $res = $mysqli->query("SELECT id, NOW() AS _time FROM test");
    $fila = $res->fetch_assoc();

    /* volcar resultados */
    var_dump($fila);

    printf("Tiempo total: %.6fs\n", microtime(true) - $inicio);

    /* pausar durante un segundo */
    sleep(1);
}
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:43:10"
}
Tiempo total: 0.000540s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:43:11"
}
Tiempo total: 0.000555s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:43:12"
}
Tiempo total: 0.000549s
]]>
    </screen>
   </example>
  </para>
  <para>
   Es posible habilitar el almacenamiento en caché para todas las sentecias incluyendo aquellas
   que tienen columnas en su conjunto de resultados para las cuales MySQL no notifica una tabla, como
   la sentencia del ejemplo. Se ha de establecer
   <link linkend="ini.mysqlnd-qc.cache-no-table"><literal>mysqlnd_qc.cache_no_table = 1</literal></link>
   para habilitar el almacenamiento en caché de tales sentencias. Por favor, observe la diferencia en los
   tiempos medidos para los ejemplos de arriba y de abajo.
  </para>
  <para>
   <example>
    <title>Habilitar el almacenamiento en caché de todas las sentencias usando el ajuste ini <literal>mysqlnd_qc.cache_no_table</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.cache_by_default=1
mysqlnd_qc.cache_no_table=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Conectar, crear y rellenar la tabla test */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1)");

for ($i = 0; $i < 3; $i++) {

    $inicio = microtime(true);

    /* Nota: la sentencia no será almacenada debido al uso de NOW() */
    $res = $mysqli->query("SELECT id, NOW() AS _time FROM test");
    $fila = $res->fetch_assoc();

    /* volcar resultados */
    var_dump($fila);

    printf("Tiempo total: %.6fs\n", microtime(true) - $inicio);

    /* pausar durante un segundo */
    sleep(1);
}
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:47:45"
}
Tiempo total: 0.000546s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:47:45"
}
Tiempo total: 0.000187s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:47:45"
}
Tiempo total: 0.000167s
]]>
    </screen>
   </example>
  </para>
  <note>
   <para>
    Aunque <link linkend="ini.mysqlnd-qc.cache-no-table"><literal>mysqlnd_qc.cache_no_table = 1</literal></link>
    haya sido creado para usarlo con
    <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.cache_by_default = 1</link></literal>
    está vilculado a él. El complemento evaluará
    <link linkend="ini.mysqlnd-qc.cache-no-table"><literal>mysqlnd_qc.cache_no_table</literal></link>
    siempre que se vaya a almacenar una consulta, sin importar si el almacenameinto en caché ha sido habilitado
    usando una sugerencia SQL o cualquier otra medida.
   </para>
  </note>
 </section>
 
 <section xml:id="mysqlnd-qc.per-query-ttl" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Establecer el tiempo de vida (TTL)</title>
  <para>
   La estrategia de invalidación predeterminada del complemento de caché de consultas es el Tiempo de Vida
   (<literal>TTL</literal> de 'Time To Live' en inglés). Los gestores de almacenamiento internos usarán el
   <literal>TTL</literal> predeterminado definido por el valor de configuración de PHP
   <literal><link linkend="mysqlnd-qc.configuration">mysqlnd_qc.ttl</link></literal>
   a menos que la cadena de consulta contenga una sugerencia para establecer un
   <literal>TTL</literal> diferente. El <literal>TTL</literal> se especifica en segundos.
   Por omisión, las entradas de la caché expirarán tras <literal>30</literal> segundos.
  </para>
  <para>
   El ejemplo establece <literal>mysqlnd_qc.ttl=3</literal> para almacenar en caché
   sentencias durante tres segundos por omisión. Cada segundo se actualiza
   un registro de la tabla de la base de datos para mantener el tiempo actual, y se ejecuta
   una sentencia <literal>SELECT</literal> para obtener el registro desde la base
   de datos. La sentencia <literal>SELECT</literal> se almacena en caché durante
   tres segundos debido a que está prefijada con la sugerencia SQL que habilita el almacenamiento
   en caché. La salida verifica que los resultados de la consulta son tomados
   desde la caché durante tres segundos antes de que
   sean refrescados.
  </para>
  <para>
   <example>
    <title>Establecer el TTL con el ajuste ini <literal>mysqlnd_qc.ttl</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.ttl=3
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* Conectar, crear y rellenar la tabla test */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id VARCHAR(255))");

for ($i = 0; $i < 7; $i++) {

    /* actualizar la fila de la BD  */
    if (!$mysqli->query("DELETE FROM test") ||
        !$mysqli->query("INSERT INTO test(id) VALUES (NOW())"))
      /* Por supuesto, un script de la vida real debería realizar un manejo de errores mejor */
      die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

    /* seleccionar la última fila pero almacenando en caché los resultados */
    $consulta  = "/*" . MYSQLND_QC_ENABLE_SWITCH . "*/";
    $consulta .= "SELECT id AS _time FROM test";
    if (!($res = $mysqli->query($consulta)) ||
        !($fila = $res->fetch_assoc()))
    {
      printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
    }
    $res->free();
    printf("Hora actual %s - Hora de la fila de la BD %s\n", date("H:i:s"), $fila['_time']);

    /* pausar durante un segundo */
    sleep(1);
}
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
Hora actual 14:55:59 - Hora de la fila de la BD 2012-01-11 14:55:59
Hora actual 14:56:00 - Hora de la fila de la BD 2012-01-11 14:55:59
Hora actual 14:56:01 - Hora de la fila de la BD 2012-01-11 14:55:59
Hora actual 14:56:02 - Hora de la fila de la BD 2012-01-11 14:56:02
Hora actual 14:56:03 - Hora de la fila de la BD 2012-01-11 14:56:02
Hora actual 14:56:04 - Hora de la fila de la BD 2012-01-11 14:56:02
Hora actual 14:56:05 - Hora de la fila de la BD 2012-01-11 14:56:05
]]>
    </screen>
   </example>
  </para>
  <para>
   Como se puede ver en el ejemplo, cualquier caché basada en <literal>TTL</literal>
   puede servir datos antiguos. Las entradas de la caché no son automáticamente invalidadas
   si cambian los datos subyacentes. Las aplicaciones que usen la estragegia de invalidacón de
   <literal>TTL</literal> predeterminada deben poder funcionar correctamente
   con datos antiguos.
  </para>
  <para>
   Un gestor de almacenamiento definido por el usuario puede implementar cualquier estrategia de
   invalidación para evitar esta limitación.
  </para>
  <para>
   El <literal>TTL</literal> predeterminado se puede sobrescribir usando la sugerencia SQL
   <literal>/*qc_tt=seconds*/</literal>. Esta sugerencia SQL debe aparecer inmediatamente
   después de la sugerencia SQL que habilita el almacenamiento en caché. Se recomienda usar la constante de PHP
   <literal><link linkend="mysqlnd-qc.constants">MYSQLND_QC_TTL_SWITCH</link></literal>
   en lugar del valor de cadena.
  </para>
  <para>
   <example>
    <title>Establecer el TTL con sugerencias SQL</title>
    <programlisting role="php">
<![CDATA[
<?php
$inicio = microtime(true);

/* Conectar, crear y rellenar la tabla test */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

printf("TTL predeterminado\t: %d segundos\n", ini_get("mysqlnd_qc.ttl"));

/* Será almacenada en caché durante 2 segundos */
$sql = sprintf("/*%s*//*%s%d*/SELECT id FROM test WHERE id = 1", MYSQLND_QC_ENABLE_SWITCH, MYSQLND_QC_TTL_SWITCH, 2);
$res = $mysqli->query($sql);

var_dump($res->fetch_assoc());
$res->free();

$mysqli->query("DELETE FROM test WHERE id = 1");
sleep(1);

/* Coincidencia con la caché - ¡sin invalidación automática y aún válida! */
$res = $mysqli->query($sql);
var_dump($res->fetch_assoc());
$res->free();

sleep(2);

/* No coincide con la caché - la entrada de la caché ha expirado */
$res = $mysqli->query($sql);
var_dump($res->fetch_assoc());
$res->free();

printf("Tiempo de ejecución del script\t: %d segundos\n", microtime(true) - $inicio);
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
TTL predeterminado      : 30 segundos
array(1) {
  ["id"]=>
  string(1) "1"
}
array(1) {
  ["id"]=>
  string(1) "1"
}
NULL
Tiempo de ejecución del script  : 3 segundos
]]>
    </screen>
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.pattern-based-caching" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Almacenamiento en caché basado en patrones</title>
  <para>
   Una aplicación tiene tres opciones para indicarle a PECL/mysqlnd_qc si será usada
   una sentencia en particular. El enfoque más básico es almacenar en caché todas las sentencias
   estableciendo <literal><link linkend="mysqlnd-qc.configuration">
   mysqlnd_qc.cache_by_default = 1</link></literal>. Este enfoque a menudo es poco
   práctico, aunque habilita a los usuarios realizar una estimación rápida sobre
   las ganancias de rendimiento máximas de la caché. Una aplicación diseñada para
   usar una caché podría prefijar las sentencias seleccionadas con las sugerencias SQL
   apropiadas. Sin embargo, alterar el código fuente de una aplicación podría no ser siempre posible
   o deseado, por ejemplo, para evitar problemas con actualizaciones de software. Por ello,
   PECL/mysqlnd_qc permite establecer una llamada de retorno que decida si una consulta será
   almacenada en caché.
  </para>
  <para>
   La llamada de retorno se instala con la función <function>mysqlnd_qc_set_is_select</function>.
   A la llamada de retorno se le proporciona una cadena de sentencia de cada sentencia
   inspeccionada por el complemento. Luego, la llamada de retorno puede decidir si almacenará en caché
   la función. La llamada de retonro debe devolver &false;
   si la sentencia no será almacenada en caché. Un valor de retorno de &true;
   hace que el complemento intente añadir la sentencia a la caché. A la entrada de la caché
   se le dará el TTL predeterminado (<literal><link linkend="mysqlnd-qc.configuration">
   mysqlnd_qc.ttl</link></literal>). Si la llamada de retorno devuelve
   un valor numérico se usará éste como el TTL en lugar del predeterminado global.
  </para>
  <para>
   <example>
    <title>Establecer una llamada de retorno con <function>mysqlnd_qc_set_is_select</function></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_statistics=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* llamada de retorno que decice si una consulta se almacena en caché */
function is_select($consulta) {
    static $patrones = array(
      /* true - usar lo predetermiando por mysqlnd_qc.ttl */
      "@SELECT\s+.*\s+FROM\s+test@ismU" => true,
      /* 3 - usar TTL = 3 segundos */
      "@SELECT\s+.*\s+FROM\s+news@ismU" => 3
    );

    /* comprobar si la consulta coincide con el patrón */
    foreach ($patrones as $patrón => $ttl) {
        if (preg_match($patrón, $consulta)) {
            printf("is_select(%45s): almacenada\n", $consulta);
            return $ttl;
        }
    }
    printf("is_select(%45s): no almacenada\n", $consulta);
    return false;
}
/* instalar la llamada de retorno */
mysqlnd_qc_set_is_select("is_select");

/* Conectar, crear y rellenar la tabla test */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* colocada en la caché */
$mysqli->query("SELECT id FROM test WHERE id = 1");
/* coincidencia con la caché */
$mysqli->query("SELECT id FROM test WHERE id = 1");
/* colocada en la caché */
$mysqli->query("SELECT * FROM test");

$estadísticas = mysqlnd_qc_get_core_stats();
printf("Colocada en caché: %d\n", $estadísticas['cache_put']);
printf("Coincidencia con la caché: %d\n", $estadísticas['cache_hit']);
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
is_select(                    DROP TABLE IF EXISTS test): no almacenada
is_select(                    CREATE TABLE test(id INT)): no almacenada
is_select(    INSERT INTO test(id) VALUES (1), (2), (3)): no almacenada
is_select(             SELECT id FROM test WHERE id = 1): almacenada
is_select(             SELECT id FROM test WHERE id = 1): almacenada
is_select(                           SELECT * FROM test): almacenada
Colocada en caché: 2
Coincidencia con la caché: 1
]]>
    </screen>
   </example>
  </para>
  <para>
   La llamada de retorno del ejemplo comprueba si una cadena de sentencia coincide con un patrón.
   Si éste es el caso, devuelve &true; para almacenar en caché
   la consulta usando el TTL global o un TTL alternativo.
  </para>
  <para>
   Para minimizar los cambios en la aplicación, la llamada de retorno puede colocarse y registrarse
   en un fichero autoantepuesto.
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.slam-defense" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Defensa de cierre</title>
  <para>
   Una caché mal diseñada puede hacer más daño que bien. En el peor de los casos, una caché
   puede aumentar la carga del servidor de bases de datos en lugar de minimizarla. Una situación de sobrecarga
   puede ocurrir si una entrada de la caché altamente compartida expira (estampida de la caché).
  </para>
  <para>
   Las entradas de la caché son compartidas y reutilizadas en diferentes grados, dependiendo del
   almacenamiento usado. El gestor de almacenamiento predeterminado almacena entradas en la memoria del proceso.
   Así, una entrada de la caché puede ser reutilzada durante el periodo de vida de un proceso. Otros procesos
   de PHP no puede acceder a ella. Si se usa Memcache, una entrada de la caché puede ser compartida
   entre múltiples procesos de PHP e incluso entre múltiples máquinas, dependiendo de la
   configuración que se use.
  </para>
  <para>
   Si una entrada de la caché altamente compartida almacenada en, por ejemplo, Memcache expira, muchos clientes no
   obtendrán una coincidencia con la caché. Muchas peticiones de clientes ya no son servidas desde
   la caché, sino que se intenta ejecutar la consulta subyacente en el servidor de bases de datos. Hasta que
   la entrada de la caché sea refrescada, más y más clientes contactarán con el servidor de bases de datos.
   En el peor de los casos, el resultado será la pérdida total del servicio.
  </para>
  <para>
   La sobrecarga se puede evitar usando un gestor de almacenamiento que limite la reutilización de entradas
   de la caché a unos pocos clientes. Entonces, como media, es probable que sólo un número limitado
   de clientes intenten refrescar una entrada de la caché de forma concurrente.
  </para>
  <para>
   Adicionalmente, el mecanismo interno de defensa de cierre puede y debería usarse. Si
   está activada la defensa de cierre, a una entrada expirada se le amplía el tiempo de vida.
   El primer cliente que no obtenga una coincidencia con la caché para la entrada expirada intentará
   refrescar dicha entrada dentro del tiempo de vida ampliado. Todos los demás clientes que soliciten
   la entrada de la caché son servidos temporalmente desde la caché aunque el
   <literal>TTL</literal> original de dicha entrada haya expirado. Los demás clientes no
   experimentarán una no coincidencia con la caché antes de que se agote el tiempo de vida.
  </para>
  <para>
   <example>
    <title>Habilitar el mecanismo de defensa de cierre</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.slam_defense=1
mysqlnd_qc.slam_defense_ttl=1
]]>
    </programlisting>
   </example>
  </para>
  <para>
   El mecanismo de defensa de cierre se habilita con la directiva de configuración
   <link linkend="ini.mysqlnd-qc.slam-defense"><literal>mysqlnd_qc.slam_defense</literal></link>.
   El tiempo de vida ampliado de una entrada de la caché se establece con
   <link linkend="ini.mysqlnd-qc.slam-defense-ttl"><literal>mysqlnd_qc.slam_defense_ttl</literal></link>.
  </para>
  <para>
   La función
   <function>mysqlnd_qc_get_core_stats</function> devuelve un array de
   estadísticas. Las estadísticas <literal>slam_stale_refresh</literal> y
   <literal>slam_stale_hit</literal> son incrementadas si la defensa de cierre tiene lugar.
  </para>
  <para>
   No es posible establecer una recomendación universal en la configuración de la defensa de cierre.
   Se advierte a los usuarios que monitoricen y prueben sus configuraciones y que deduzcan
   los ajustes en consecuencia.
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.cache-candidates" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Buscar candidatas a la caché</title>
  <para>
   Una sentencia debería ser considerada para ser almacenada en la caché si se ejecuta a menudo y tiene
   un tiempo de ejecución largo. Las candidatas se buscan creando una lista de sentencias
   ordenadas por el producto del número de ejecuciones multiplicado por el
   tiempo de ejecución de la sentencia. La función
   <function>mysqlnd_qc_get_query_trace_log</function>
   devuelve un registro de consultas que ayudan con la tarea.
  </para>
  <para>
   Recopilar el rastreo de una consulta es una operación lenta. Por lo tanto, está deshabilitada de forma predeterminada.
   La directiva de configuración de PHP
   <link linkend="ini.mysqlnd-qc.collect-query-trace"><literal>mysqlnd_qc.collect_query_trace</literal></link>
   se usa para habilitarla. El rastreo de la función contiene una entrada para cada
   consulta emitida antes de llamar a la función.
  </para>
  <para>
   <example>
    <title>Recopilar un rastreo de consulta</title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_query_trace=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* conectarse a MySQL */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");

/* consultas varias para rellenar el rastreo de consultas */
for ($i = 0; $i < 2; $i++) {
    $res = $mysqli->query("SELECT 1 AS _one FROM DUAL");
    $res->free();
}

/* volcar el rastreo */
var_dump(mysqlnd_qc_get_query_trace_log());
?>
]]>
    </programlisting>
    &examples.outputs;
    <screen>
<![CDATA[
array(2) {
  [0]=>
  array(8) {
    ["query"]=>
    string(26) "SELECT 1 AS _one FROM DUAL"
    ["origin"]=>
    string(102) "#0 qc.php(7): mysqli->query('SELECT 1 AS _on...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(25)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
  [1]=>
  array(8) {
    ["query"]=>
    string(26) "SELECT 1 AS _one FROM DUAL"
    ["origin"]=>
    string(102) "#0 qc.php(7): mysqli->query('SELECT 1 AS _on...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(8)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
}
]]>
    </screen>
   </example>
  </para>
  <para>
   El rastreo se da con información desordenada. También se dan
   los tiempos y el origen de la llamada de la consulta. La propiedad 'origin'
   contiene un código de búsqueda de rastros para identificar el origen de la consulta.
   La profundidad de la búsqueda de rastros se puede limitar con
   la directiva de configuración de PHP
   <link linkend="ini.mysqlnd-qc.query-trace-bt-depth"><literal>mysqlnd_qc.query_trace_bt_depth</literal></link>.
   La profundidad predeterminada es <literal>3</literal>.
  </para>
  <para>
   <example>
    <title>Establecer la profundidad de la búsqueda de rastros con el ajuste ini <literal>mysqlnd_qc.query_trace_bt_depth</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_query_trace=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* conectarse a MySQL */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* consultas varias para rellenar el rastreo de consultas */
for ($i = 0; $i < 3; $i++) {
    $res = $mysqli->query("SELECT id FROM test WHERE id = " . $mysqli->real_escape_string($i));
    $res->free();
}

$rastreo = mysqlnd_qc_get_query_trace_log();
$resumen = array();
foreach ($rastreo as $entrada) {
    if (!isset($resumen[$entrada['query']])) {
        $resumen[$entrada['query']] = array(
            "executions" => 1,
            "time"       => $entrada['run_time'] + $entrada['store_time'],
        );
    } else {
        $resumen[$entrada['query']]['executions']++;
        $resumen[$entrada['query']]['time'] += $entrada['run_time'] + $entrada['store_time'];
    }
}

foreach ($resumen as $consulta => $detalles) {
    printf("%45s: %5dms (%dx)\n",
    $consulta, $detalles['time'], $detalles['executions']);
}
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
                    DROP TABLE IF EXISTS test:     0ms (1x)
                    CREATE TABLE test(id INT):     0ms (1x)
    INSERT INTO test(id) VALUES (1), (2), (3):     0ms (1x)
             SELECT id FROM test WHERE id = 0:    25ms (1x)
             SELECT id FROM test WHERE id = 1:    10ms (1x)
             SELECT id FROM test WHERE id = 2:     9ms (1x)
]]>
    </screen>
   </example>
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.cache-efficiency" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Medir la eficiencia de la caché</title>
  <para>
   PECL/mysqlnd_qc ofrece tres maneras de medir la eficiencia de la caché.
   La función
   <function>mysqlnd_qc_get_normalized_query_trace_log</function>
   devuelve estadísticas acumuladas por la cadena de consulta normalizada,
   <function>mysqlnd_qc_get_cache_info</function>
   proporciona información específica del gestor de almacenamiento que incluye una lista
   de todos los elementos almacenados en la caché, dependiendo de dicho gestor. Adicionalmente, el
   núcleo de PECL/mysqlnd_qc recopila estadísticas de resumen de alto nivel acumuladas
   por cada proceso de PHP. Las estadísticas de alto nivel son devueltas por
   <function>mysqlnd_qc_get_core_stats</function>.
  </para>
  <para>
   Las funciones
   <function>mysqlnd_qc_get_normalized_query_trace_log</function>
   y
   <function>mysqlnd_qc_get_core_stats</function>
   no recopilarán datos a menos que dicha recopilación haya sido
   habilitada a través de sus directivas de configuración de PHP correspondientes. La recopilación de datos
   está deshabilitada de forma predeterminada por consideraciones de rendimiento. Se puede configurar con la opción
   <link linkend="ini.mysqlnd-qc.time-statistics">mysqlnd_qc.time_statistics</link>,
   la cual determina si se debería recopilar la información de los tiempos.
   La recopilación de las estadísticas de tiempo está habiltada de forma predeterminada,
   pero únicamente se lleva cabo si está habilitada la recopilación de datos en sí.
   El registro de estadísticas de tiempo ocasiona llamadas extra al sistema. En la mayoría de los casos,
   el beneficio de la monitorización es mayor que cualquier penalización de rendimiento potencial causado
   por las llamadas adicionales al sistema.
  </para>
  <para>
   <example>
    <title>Recopilar datos de estadísticas con el ajuste ini <literal>mysqlnd_qc.time_statistics</literal></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_statistics=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* conectarse a MySQL */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* consultas varias */
for ($i = 1; $i <= 4; $i++) {
    $consulta = sprintf("/*%s*/SELECT id FROM test WHERE id = %d", MYSQLND_QC_ENABLE_SWITCH, $i % 2);
    $res   = $mysqli->query($consulta);
    
    $res->free();
}

var_dump(mysqlnd_qc_get_core_stats());
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
array(26) {
  ["cache_hit"]=>
  string(1) "2"
  ["cache_miss"]=>
  string(1) "2"
  ["cache_put"]=>
  string(1) "2"
  ["query_should_cache"]=>
  string(1) "4"
  ["query_should_not_cache"]=>
  string(1) "3"
  ["query_not_cached"]=>
  string(1) "3"
  ["query_could_cache"]=>
  string(1) "4"
  ["query_found_in_cache"]=>
  string(1) "2"
  ["query_uncached_other"]=>
  string(1) "0"
  ["query_uncached_no_table"]=>
  string(1) "0"
  ["query_uncached_no_result"]=>
  string(1) "0"
  ["query_uncached_use_result"]=>
  string(1) "0"
  ["query_aggr_run_time_cache_hit"]=>
  string(2) "28"
  ["query_aggr_run_time_cache_put"]=>
  string(3) "900"
  ["query_aggr_run_time_total"]=>
  string(3) "928"
  ["query_aggr_store_time_cache_hit"]=>
  string(2) "14"
  ["query_aggr_store_time_cache_put"]=>
  string(2) "40"
  ["query_aggr_store_time_total"]=>
  string(2) "54"
  ["receive_bytes_recorded"]=>
  string(3) "136"
  ["receive_bytes_replayed"]=>
  string(3) "136"
  ["send_bytes_recorded"]=>
  string(2) "84"
  ["send_bytes_replayed"]=>
  string(2) "84"
  ["slam_stale_refresh"]=>
  string(1) "0"
  ["slam_stale_hit"]=>
  string(1) "0"
  ["request_counter"]=>
  int(1)
  ["process_hash"]=>
  int(1929695233)
}
]]>
    </screen>
   </example>
  </para>
  <para>
   Para una visión general se llama a
   <function>mysqlnd_qc_get_core_stats</function>, que emite estadísticas
   relacionadas con el uso de la caché, los tiempos  de caché y el tráfico. Los valores se acumulan
   en función de cada proceso para todas las consultas emitidas por cualquier llamada a la API de MySQL para PHP.
  </para>
  <para>
   Algunos gestores de almacenamiento, como el gestor predetermindo, pueden informar de las entradas de la caché,
   de las estadísticas relacionadas con las entradas y de los metadatos de las consultas subyacentes a través de la
   función <function>mysqlnd_qc_get_cache_info</function>.
   Por favor, observe que la información devuelta depende
   del gestor de almacenmiento. Los valores se acumulan en función de cada proceso.
  </para>
  <para>
   <example>
    <title>Ejemplo del uso de <function>mysqlnd_qc_get_cache_info</function></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* conectarse a MySQL */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* consultas varias para rellenar el rastreo de consultas */
for ($i = 1; $i <= 4; $i++) {
    $consulta = sprintf("/*%s*/SELECT id FROM test WHERE id = %d", MYSQLND_QC_ENABLE_SWITCH, $i % 2);
    $res   = $mysqli->query($consulta);
  
    $res->free();
}

var_dump(mysqlnd_qc_get_cache_info());
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
array(4) {
  ["num_entries"]=>
  int(2)
  ["handler"]=>
  string(7) "default"
  ["handler_version"]=>
  string(5) "1.0.0"
  ["data"]=>
  array(2) {
    ["Localhost via UNIX socket
3306
root
test|/*qc=on*/SELECT id FROM test WHERE id = 1"]=>
    array(2) {
      ["statistics"]=>
      array(11) {
        ["rows"]=>
        int(1)
        ["stored_size"]=>
        int(71)
        ["cache_hits"]=>
        int(1)
        ["run_time"]=>
        int(391)
        ["store_time"]=>
        int(27)
        ["min_run_time"]=>
        int(16)
        ["max_run_time"]=>
        int(16)
        ["min_store_time"]=>
        int(8)
        ["max_store_time"]=>
        int(8)
        ["avg_run_time"]=>
        int(8)
        ["avg_store_time"]=>
        int(4)
      }
      ["metadata"]=>
      array(1) {
        [0]=>
        array(8) {
          ["name"]=>
          string(2) "id"
          ["orig_name"]=>
          string(2) "id"
          ["table"]=>
          string(4) "test"
          ["orig_table"]=>
          string(4) "test"
          ["db"]=>
          string(4) "test"
          ["max_length"]=>
          int(1)
          ["length"]=>
          int(11)
          ["type"]=>
          int(3)
        }
      }
    }
    ["Localhost via UNIX socket
3306
root
test|/*qc=on*/SELECT id FROM test WHERE id = 0"]=>
    array(2) {
      ["statistics"]=>
      array(11) {
        ["rows"]=>
        int(0)
        ["stored_size"]=>
        int(65)
        ["cache_hits"]=>
        int(1)
        ["run_time"]=>
        int(299)
        ["store_time"]=>
        int(13)
        ["min_run_time"]=>
        int(11)
        ["max_run_time"]=>
        int(11)
        ["min_store_time"]=>
        int(6)
        ["max_store_time"]=>
        int(6)
        ["avg_run_time"]=>
        int(5)
        ["avg_store_time"]=>
        int(3)
      }
      ["metadata"]=>
      array(1) {
        [0]=>
        array(8) {
          ["name"]=>
          string(2) "id"
          ["orig_name"]=>
          string(2) "id"
          ["table"]=>
          string(4) "test"
          ["orig_table"]=>
          string(4) "test"
          ["db"]=>
          string(4) "test"
          ["max_length"]=>
          int(0)
          ["length"]=>
          int(11)
          ["type"]=>
          int(3)
        }
      }
    }
  }
}
]]>
    </screen>
   </example>
  </para>
  <para>
   Es posible disminuir más la granularidad de las estadísticas
   al nivel de la cadena de sentencia normalizada.
   Ésta es la cadena de sentencia con todos los parámetros
   reemplazados con signos de interrogación. Por ejemplo, las dos sentencias
   <literal>SELECT id FROM test WHERE id = 0</literal> y
   <literal>SELECT id FROM test WHERE id = 1</literal> se normalizan a
   <literal>SELECT id FROM test WHERE id = ?</literal>. Sus estadísticas
   se acumulan en una entrada para
   <literal>SELECT id FROM test WHERE id = ?</literal>.
  </para>
  <para>
   <example>
    <title>Ejemplo del uso de <function>mysqlnd_qc_get_normalized_query_trace_log</function></title>
    <programlisting role="ini">
<![CDATA[
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_normalized_query_trace=1
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
<?php
/* conectarse a MySQL */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* consultas varias para rellenar el rastreo de consultas */
for ($i = 1; $i <= 4; $i++) {
    $consulta = sprintf("/*%s*/SELECT id FROM test WHERE id = %d", MYSQLND_QC_ENABLE_SWITCH, $i % 2);
    $res   = $mysqli->query($consulta);
  
    $res->free();
}

var_dump(mysqlnd_qc_get_normalized_query_trace_log());
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
array(4) {
  [0]=>
  array(9) {
    ["query"]=>
    string(25) "DROP TABLE IF EXISTS test"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [1]=>
  array(9) {
    ["query"]=>
    string(27) "CREATE TABLE test (id INT )"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [2]=>
  array(9) {
    ["query"]=>
    string(46) "INSERT INTO test (id ) VALUES (? ), (? ), (? )"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [3]=>
  array(9) {
    ["query"]=>
    string(31) "SELECT id FROM test WHERE id =?"
    ["occurences"]=>
    int(4)
    ["eligible_for_caching"]=>
    bool(true)
    ["avg_run_time"]=>
    int(179)
    ["min_run_time"]=>
    int(11)
    ["max_run_time"]=>
    int(393)
    ["avg_store_time"]=>
    int(12)
    ["min_store_time"]=>
    int(7)
    ["max_store_time"]=>
    int(25)
  }
}
]]>
    </screen>
   </example>
  </para>
  <para>
   La distribución del código fuente de PECL/mysqlnd_qc contiene el directorio
   <literal>web/</literal> en el que se pueden encontrar scripts basados en
   monitorización que proporcionan un ejemplo de cómo escribir un monitor de caché.
   Por favor, siga las instrucciones proporcionadas en el código fuente.
  </para>
  <para>
   Desde PECL/mysqlnd_qc 1.1.0 es posible escribir estadísticas en un fichero
   de registro. Véase <literal><link linkend="ini.mysqlnd-qc.collect-statistics-log-file">
   mysqlnd_qc.collect_statistics_log_file</link></literal>.
  </para>
 </section>
 
 <section xml:id="mysqlnd-qc.set-user-handlers" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Más allá del TTL: almacenamiento definido por el usuario</title>
  <para>
   El complemento de caché de consultas admite el uso de gestores de almacenamiento definidos por el usuario.
   Éstos pueden usar algoritmos de invalidacion complejos de forma
   arbitraria y admitir medios de almacenamiento arbitrarios.
  </para>
  <para>
   Todos los gestores de almacenamiento definidos por el usuario deben proporcionar una cierta interfaz.
   Las funciones del gestor de almacenamiento definido por el usuario serán llamadas por el
   núcleo del complemento de caché. La interfaz necesaria consiste en siete
   funciones públicas. El gestor de almacenamiento definido por el usuario, tanto procedimental
   como el orientado a objetos, debe implementar el mismo conjunto de funciones.
  </para>
  <para>
   <example>
    <title>Utilizar un gestor de almacenamiento definido por el usuario</title>
    <programlisting role="php">
<![CDATA[
<?php
/* Habilitar el almacenamiento en la caché predeterminado para todas las sentencas */
ini_set("mysqlnd_qc.cache_by_default", 1);

/* Funciones del gestor de almacenamiento procedimental definido por el usuario */

$__cache = array();

function get_hash($host_info, $port, $user, $db, $query) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    return md5(sprintf("%s%s%s%s%s", $host_info, $port, $user, $db, $query));
}

function find_query_in_cache($key) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    if (isset($__cache[$key])) {
        $tmp = $__cache[$key];
        if ($tmp["valid_until"] < time()) {
            unset($__cache[$key]);
            $ret = NULL;
        } else {
            $ret = $__cache[$key]["data"];
        }
    } else {
        $ret = NULL;
    }

    return $ret;
}

function return_to_cache($key) {
    /*
     Invocada en una búsqueda coincidente en la caché después de haber procesado el
     almacenamiento de los datos, podría usarse como cuenta de referencia
    */
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());
}

function add_query_to_cache_if_not_exists($key, $data, $ttl, $run_time, $store_time, $row_count) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    $__cache[$key] = array(
        "data"               => $data,
        "row_count"          => $row_count,
        "valid_until"        => time() + $ttl,
        "hits"               => 0,
        "run_time"           => $run_time,
        "store_time"         => $store_time,
        "cached_run_times"   => array(),
        "cached_store_times" => array(),
    );

    return TRUE;
}

function query_is_select($query) {
    printf("\t%s('%s'): ", __FUNCTION__, $query);

    $ret = FALSE;
    if (stristr($query, "SELECT") !== FALSE) {
        /* almacenar en caché durante 5 segundos */
        $ret = 5;
    }

    printf("%s\n", (FALSE === $ret) ? "FALSE" : $ret);
    return $ret;
}

function update_query_run_time_stats($key, $run_time, $store_time) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    if (isset($__cache[$key])) {
        $__cache[$key]['hits']++;
        $__cache[$key]["cached_run_times"][] = $run_time;
        $__cache[$key]["cached_store_times"][] = $store_time;
    }
}

function get_stats($key = NULL) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    if ($key && isset($__cache[$key])) {
        $stats = $__cache[$key];
    } else {
        $stats = array();
        foreach ($__cache as $key => $details) {
            $stats[$key] = array(
               'hits'              => $details['hits'],
               'bytes'             => strlen($details['data']),
               'uncached_run_time' => $details['run_time'],
               'cached_run_time'   => (count($details['cached_run_times']))
                                      ? array_sum($details['cached_run_times']) / count($details['cached_run_times'])
                                      : 0,
            );
        }
    }

    return $stats;
}

function clear_cache() {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    $__cache = array();
    return TRUE;
}

/* Instalar el gestor de almacenamiento procedimental definido por el usuario */
if (!mysqlnd_qc_set_user_handlers("get_hash", "find_query_in_cache",
    "return_to_cache", "add_query_to_cache_if_not_exists",
    "query_is_select", "update_query_run_time_stats", "get_stats", "clear_cache")) {
  
        printf("Fallo al instalar el gestor de almacenmiento definido por el usuario\n");
}


/* Conectar, crear y rellenar la tabla test */
$mysqli = new mysqli("host", "usuario", "contraseña", "esquema", "puerto", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

printf("\nColocada en caché/sin coincidencia en la caché\n");

$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

/* Borrar el registro para verificar que obtenemos los datos desde la caché */
$mysqli->query("DELETE FROM test WHERE id = 1");

printf("\nCoincidencia con la caché\n");

$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

printf("\nMostrar las estadísticas de la caché\n");
var_dump(mysqlnd_qc_get_cache_info());

printf("\nVolcado de la caché, colocada en la caché/sin coincidencia en la caché");
var_dump(mysqlnd_qc_clear_cache());

$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();
?>
]]>
    </programlisting>
    &examples.outputs.similar;
    <screen>
<![CDATA[
        query_is_select('DROP TABLE IF EXISTS test'): FALSE
        query_is_select('CREATE TABLE test(id INT)'): FALSE
        query_is_select('INSERT INTO test(id) VALUES (1), (2)'): FALSE

Colocada en caché/sin coincidencia en la caché
        query_is_select('SELECT id FROM test WHERE id = 1'): 5
        get_hash(5)
        find_query_in_cache(1)
        add_query_to_cache_if_not_exists(6)
array(1) {
  ["id"]=>
  string(1) "1"
}
        query_is_select('DELETE FROM test WHERE id = 1'): FALSE

Coincidencia con la caché
        query_is_select('SELECT id FROM test WHERE id = 1'): 5
        get_hash(5)
        find_query_in_cache(1)
        return_to_cache(1)
        update_query_run_time_stats(3)
array(1) {
  ["id"]=>
  string(1) "1"
}

Mostrar las estadísticas de la caché
        get_stats(0)
array(4) {
  ["num_entries"]=>
  int(1)
  ["handler"]=>
  string(4) "user"
  ["handler_version"]=>
  string(5) "1.0.0"
  ["data"]=>
  array(1) {
    ["18683c177dc89bb352b29965d112fdaa"]=>
    array(4) {
      ["hits"]=>
      int(1)
      ["bytes"]=>
      int(71)
      ["uncached_run_time"]=>
      int(398)
      ["cached_run_time"]=>
      int(4)
    }
  }
}

Volcado de la caché, colocada en la caché/sin coincidencia en la caché    clear_cache(0)
bool(true)
        query_is_select('SELECT id FROM test WHERE id = 1'): 5
        get_hash(5)
        find_query_in_cache(1)
        add_query_to_cache_if_not_exists(6)
NULL

]]>
    </screen>
   </example>
  </para>
 </section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
