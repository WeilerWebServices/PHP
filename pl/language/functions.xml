<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 346309 Maintainer: sobak Status: ready -->
<!-- $Revision$ -->
<!-- CREDITS: pirate -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Funkcje</title>

  <sect1 xml:id="functions.user-defined">
   <title>Funkcje definiowane przez użytkownika</title>
 
   <para>
    Funkcja może być definiowana przy użyciu następującej składni:
   </para>
   <para>
    <example>
     <title>Pseudokod demonstrujący użycie funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Przykładowa funkcja.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <simpara>
    Każdy poprawny kod może być użyty wewnątrz funkcji,
    łącznie z definicjami innych funkcji i 
    <link linkend="language.oop5.basic.class">klas</link>.
   </simpara>
   <para>
    Nazwy funkcji obowiązują identyczne zasady, jak w przypadku wszystkich innych etykiet w PHP. 
    Poprawna nazwa funkcji zaczyna się od litery lub podkreślnika, po których następuje 
    dowolna ilość liter, cyfr i podkreślników. Jako wyrażenie regularne, określone 
    zostałoby to następująco: 
    <code>[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</code>.
   </para>
   &tip.userlandnaming;
   <simpara>
    Funkcje nie muszą być zdefiniowane przed odniesieniem się do nich,
    <emphasis>oprócz</emphasis> sytuacji, w których funkcja jest
    zdefiniowana warunkowo jak w dwóch poniższych przykładach.
   </simpara>
   <para>
    Kiedy funkcja jest zdefiniowana warunkowo, jak w dwóch poniższych przykładach,
    jej definicja musi być przetworzona <emphasis>przed</emphasis>
    jej wywołaniem.
   </para>
   <para>
    <example>
     <title>Funkcje zdefiniowane warunkowo</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* Nie możemy tu wywołać foo() 
   ponieważ jeszcze nie istnieje,
   ale możemy wywołać bar() */

bar();

if ($makefoo) {
  function foo()
  {
    echo "Nie istnieję, dopóki nie zostanę wykonana.\n";
  }
}

/* Teraz możemy bezpiecznie wywołać foo()
   ponieważ $makefoo ma wartość logiczną 1 */

if ($makefoo) foo();

function bar() 
{
  echo "Istnieję od początku działania skryptu.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>Funkcje wewnątrz funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "Nie istnieję, dopóki foo() nie jest wywołana.\n";
  }
}

/* Nie możemy tu wywołać bar() 
   ponieważ jeszcze nie istnieje. */

foo();

/* Teraz możemy wywołać bar(),
   wykonanie foo() spodowało
   że jest to już możliwe. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Wszystkie funkcje i klasy w PHP mają globalny zasięg - mogą być
    wykonane poza funkcją, nawet jeśli były zdefiniowane wewnątrz niej, i odwrotnie.
   </para>
   <simpara>
    PHP nie umożliwia przeładowywania funkcji, nie jest też możliwe
    usunięcie jej definicji lub redefiniowanie poprzednio określonych funkcji.
   </simpara>
   <note>
    <simpara>
     Nazwy funkcji nie rozróżniają wielkości liter, ale dobrym zwyczajem jest
     wywoływanie ich w formie, w której zostały zdefiniowane.
    </simpara>
   </note>   
   <simpara>
    Zarówno <link linkend="functions.variable-arg-list">przyjmowanie różnej ilości
    argumentów</link> jak i <link linkend="functions.arguments.default">wartości domyślne
    argumentów</link> są obsługiwane w funkcjach. Zobacz także opisy
    funkcji
    <function>func_num_args</function>,
    <function>func_get_arg</function>, i
    <function>func_get_args</function> aby uzyskać więcej informacji.
   </simpara>
   
   <para>
    W PHP jest możliwe wykonywanie rekurencyjnych funkcji.
    <example>
     <title>Funkcje rekurencyjne</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   <note>
    <simpara>
     Rekurencyjne wywoływanie funkcji/metod z ponad 100-200 poziomami rekurencji
     może spowodować przepełnienie stosu i zakończenie wykonywania skryptu. W
     szczególności nieskończona rekurencja jest uznawana za błąd programistyczny.
    </simpara>
   </note>
   </para>

  </sect1>
 
  <sect1 xml:id="functions.arguments">
   <title>Argumenty funkcji</title>
 
   <simpara>
    Dane mogą być przekazywane do funkcji przez listę argumentów,
    która jest listą oddzielonych przecinkami wyrażeń. Argumenty są wykonywane
    od prawej do lewej.
   </simpara>

   <para>
    PHP obsługuje podawanie argumentów jako wartości (domyślnie), <link
    linkend="functions.arguments.by-reference">przez
    referencję</link>, oraz <link
    linkend="functions.arguments.default">domyślne wartości
    argumentów</link>. <link linkend="functions.variable-arg-list">Różna ilość
    argumentów</link> także jest obsługiwana.
   </para>
   <para>
    <example>
     <title>Tablica jako argument funkcji</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>
 
   <sect2 xml:id="functions.arguments.by-reference">
    <title>Podawanie argumentów jako referencji</title>
 
    <simpara>
     Domyślnie, argumenty funkcji podawane są jako wartości (kiedy
     wartość argumentu wewnątrz funkcji się zmienia, nie wpływa
     to na wartość zmiennej poza funkcją). Aby pozwolić funkcji na modyfikację jej
     jej argumentów, muszą one być podane przez referencję.
    </simpara>
    <para>
     Aby argument zawsze był podawany przez referencję, poprzedź nazwę
     argumentu znakiem (&amp;) w definicji funkcji:
    </para>
    <para>
     <example>
      <title>Podawanie parametrów funkcji przez referencję</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'i coś ekstra.';
}
$str = 'To jest ciąg znaków, ';
add_some_extra($str);
echo $str;    // wypisuje 'To jest ciąg znaków, i coś ekstra.'
?>
]]>
      </programlisting>
     </example>
    </para>
   </sect2>
   <sect2 xml:id="functions.arguments.default">
    <title>Domyślne wartości argumentów</title>
 
    <para>
     Można zdefiniować domyślne wartości skalarne 
     argumentów w stylu C++ następująco:
    </para>
    <para>
     <example>
      <title>Użycie domyślnych wartości argumentów w funkcji</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "cappuccino")
{
    return "Robię filiżankę $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("espresso");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Robię filiżankę cappuccino.
Robię filiżankę .
Robię filiżankę espresso.
]]>
      </screen>
     </example>
    </para>
    <para>
     PHP pozwala również na użycie tablic(<type>array</type>) i specjalnego typu &null;
     jako domyślnych wartości, na przykład:
    </para>
    <para>
     <example>
      <title>Użycie nie-skalarnych typów jako domyślnych wartości</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "rąk" : $coffeeMaker;
    return "Robię kubek ".join(", ", $types)." za pomocą $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    
    </para>
    <simpara>
     Domyślna wartość musi być stałym wyrażeniem, a nie na przykład
     zmienną, członkiem klasy czy wywołaniem funkcji.
    </simpara>
    <para>
     Zauważ, że przy użyciu domyślnych wartości, powinne one być
     zdefiniowane po prawej stronie nie-domyślnych argumentów; 
     W przeciwnym wypadku, nie zadziała to jak powinno. Na przykład: 
    </para>
    <para>
     <example>
      <title>Niepoprawne użycie domyślnych wartości argumentów</title>
      <programlisting role="php">
<![CDATA[
<?php
function jogurt($typ = "homogenizowany", $smak)
{
    return "Robię $typ jogurt $smak.\n";
}
 
echo jogurt("malinowy");   // nie zadziała tak, jak oczekujemy
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Missing argument 2 in call to jogurt() in 
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Robię malinowy jogurt .
]]>
      </screen>
     </example>
    </para>
    <para>
     Porównaj go teraz z:
    </para>
    <para>
     <example>
      <title>Poprawne użycie domyślnych wartości argumentów</title>
      <programlisting role="php">
<![CDATA[
<?php
function jogurt($smak, $typ = "homogenizowany")
{
    return "Robię $typ jogurt $smak.\n";
}
 
echo makeyogurt("malinowy");   // działa zgodnie z naszymi oczekiwaniami
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Robię homogenizowany jogurt malinowy.
]]>
      </screen>
     </example>
    </para>
    
    <note>
     <simpara>
      Od PHP 5 argumenty, które są przekazywane przez referencję, mogą mieć wartości domyślne.
     </simpara>
    </note>
   </sect2>

   <sect2 xml:id="functions.arguments.type-declaration">
    <title>Deklaracje typów</title>

    <note>
     <para>
      Deklaracje typów w PHP 5 były znane jako <literal>type hinting</literal>.
     </para>
    </note>

    <para>
     Dekleracje typów pozwalają funkcjom na wymaganie argumentów określonego typu podczas ich wywoływania.
     Jeżeli dana wartość nie jest oczekiwanego typu,
     generowany jest błąd: w PHP 5 był to recoverable fatal error,
     a PHP 7 rzuci wyjątek <classname>TypeError</classname>.
    </para>

    <para>
     Aby określić deklarację typu, nazwa typu musi być podana przed nazwą
     parametru. Można zadeklarować parametr tak, aby przyjmował wartości
     typu &null;, jeżeli jego wartość domyślną ustawimy na &null;
    </para>

    <sect3 xml:id="functions.arguments.type-declaration.types">
     <title>Prawidłowe typy</title>
     <informaltable>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Typ</entry>
         <entry>Opis</entry>
         <entry>Minimalna wersja PHP</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Nazwa klasy/interfejsu</entry>
         <entry>
          Argument musi być instancją klasy o danej nazwie lub implementującą
          podany interfejs.
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><literal>self</literal></entry>
         <entry>
          Parametr musi być instancją tej samej klasy, w której zdefiniowano
          metodę. Tego typu można użyć tylko w metodach klasy lub instancji.
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><type>array</type></entry>
         <entry>
          Argument musi być tablicą (<type>array</type>).
         </entry>
         <entry>PHP 5.1.0</entry>
        </row>
        <row>
         <entry><type>callable</type></entry>
         <entry>
          Argument musi być typu <type>callable</type>.
         </entry>
         <entry>PHP 5.4.0</entry>
        </row>
        <row>
         <entry><type>bool</type></entry>
         <entry>
          Argument musi być typu logicznego (<type>boolean</type>).
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>float</type></entry>
         <entry>
          Argument musi być liczbą zmiennoprzecinkową (<type>float</type>).
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>int</type></entry>
         <entry>
          Argument musi być liczbą całkowitą (<type>integer</type>).
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>string</type></entry>
         <entry>
          Argument musi być łańcuchem znaków (<type>string</type>).
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><literal>iterable</literal></entry>
         <entry>
          Argument musi być tablicą (<type>array</type>) lub &instanceof; <classname>Traversable</classname>.
         </entry>
         <entry>PHP 7.1.0</entry>
        </row>
        <row>
         <entry><literal>object</literal></entry>
         <entry>
          Argument musi być obiektem (<type>object</type>).
         </entry>
         <entry>PHP 7.2.0</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>

	 <warning>
      <para>
	   Aliasy powyższych typów skalarnych nie są obsługiwane. Zostaną one w
       natomiast potraktowane jak nazwy klas lub interfejsów. Przykładowo,
       użycie <literal>boolean</literal> jako zwracanego typu lub typu argumentu
       będzie wymagało, aby argument lub zwracana wartość były instancją klasy
       lub interfejsu o nazwie <literal>boolean</literal> a nie typu <type>bool</type>:
      </para>
      <para>
       <example>
        <programlisting role="php">
 <![CDATA[
 <?php
 function test(boolean $param) {}
 test(true);
 ?>
 ]]>
        </programlisting>
        &example.outputs;
        <screen>
 <![CDATA[
 Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1
 ]]>
        </screen>
       </example>
      </para>
     </warning>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.examples">
     &reftitle.examples;
     <example>
      <title>Podstawowe deklaracje typu klasy</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}
class D extends C {}

// Ta klasa nie rozszerza C.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C
D

Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>Podstawowa dekleracja typu interfejsu</title>
      <programlisting role="php">
<![CDATA[
<?php
interface I { public function f(); }
class C implements I { public function f() {} }

// Ta klasa nie implementuje interfejsu I.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C

Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>Typowanie argumentów przekazywanych przez referencję</title>
      <simpara>
       Zadeklarowane typy argumentów przekazywanych przez referencję są sprawdzane
       na wejściu do funkcji, ale nie gdy funkcja zwraca, więc typ argumentu może
       się zmienić po tym gdy funkcja zwróciła.
      </simpara>
      <programlisting role="php">
<![CDATA[
<?php
function array_baz(array &$param)
{
    $param = 1;
}
$var = [];
array_baz($var);
var_dump($var);
array_baz($var);
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
int(1)

Fatal error: Uncaught TypeError: Argument 1 passed to array_baz() must be of the type array, int given, called in %s on line %d
]]>
      </screen>
     </example>
     <example>
      <title>Deklaracje typu akceptujące &null;</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function f(C $c = null) {
    var_dump($c);
}

f(new C);
f(null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
NULL
]]>
      </screen>
     </example>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.strict">
     <title>Typowanie ścisłe</title>

     <para>
      Domyślnie PHP wymusi zmianę nieprawidłowego typu na poprawny, o ile jest
      to możliwe. Przykładowo, funkcja, ktora otrzymała argument typu
      <type>integer</type>, mimo iż oczekiwała łańcucha znaków, ostatecznie
      otrzyma zmienną typu <type>string</type>.
     </para>

     <para>
      Dla danego pliku można włączyć tryb ścisły. W trybie ścisłym zaakeptowana
      będzie tylko zmienna dokładnie takiego typu, w przeciwnym wypadku zostanie
      rzucony wyjątek <classname>TypeError</classname>. Jedynym odstępstwem od
      reguły jest przekazanie <type>integer</type>a do funkcji oczekującej typu
      <type>float</type>. Wywołania funkcji z wewnątrz wbudowanych funkcji nie są
      dotknięte deklaracją <literal>strict_types</literal>.
     </para>

     <para>
      Do włączenia trybu ścisłego używana jest konstrukcja &declare; połączona z
      deklaracją <literal>strict_types</literal>:
     </para>

     <caution>
      <para>
       Włączenie trybu ścisłego ma także wpływ na
       <link linkend="functions.returning-values.type-declaration">deklaracje typu zwracanych wartości</link>.
      </para>
     </caution>

     <note>
      <para>
       Ścisłe typowanie odnosi się do wywołań funkcji
       <emphasis>wewnątrz</emphasis> pliku z włączonym ścisłym typowaniem, nie do
       funkcji zadeklarowanych w tym pliku. Jeżeli plik bez włączonego ścisłego
       typowania wykonuje funkcję zadeklarowaną w pliku z włączonym ścisłym
       typowaniem, to pod uwagę wzięte zostanie ustawienie z pliku wywołującego
       (brak ścisłego typowania), a więc wartość będzie miała dopasowany typ.
      </para>
     </note>

     <note>
      <para>
       Ścisłe typowanie działa tylko dla deklaracji typów skalarnych (scalar
       type declarations), a więc wymaga PHP 7.0.0 lub nowszego, ponieważ
       dopiero tam zostały one dodane.
      </para>
     </note>

     <example>
      <title>Ścisłe typowanie</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
]]>
      </screen>
     </example>

     <example>
      <title>Słabe typowanie</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// Te wartości zostaną przekształcone na liczby całkowite: zwróć uwagę na wynik działania!
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
int(3)
]]>
      </screen>
     </example>

     <example>
      <title>Łapanie wyjątku <classname>TypeError</classname></title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Błąd: '.$e->getMessage();
}
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10
]]>
      </screen>
     </example>
    </sect3>
   </sect2>
   <sect2 xml:id="functions.variable-arg-list">
    <title>Podawanie różnej ilości argumentów</title>

    <simpara>
     PHP wspiera użycie różnej ilości argumentów dla
     funkcji definiowanych przez użytkownika. Jest to możliwe dzięki użyciu
     tokena <literal>...</literal> w PHP 5.6 i nowszych lub dzięki funkcjom
     <function>func_num_args</function>,
     <function>func_get_arg</function> i
     <function>func_get_args</function> w PHP 5.5 i wcześniejszych.
    </simpara>

    <sect3 xml:id="functions.variable-arg-list.new">
     <title><literal>...</literal> w PHP 5.6+</title>

     <para>
      W PHP 5.6 i nowszych lista argumentów może zawierać token
      <literal>...</literal>, który oznacza, że funkcja akceptuje
      zmienną ilość argumentów. Argumenty zostaną przekazane do
      do podanej zmiennej jako tablica, na przykład:

      <example>
       <title>Użycie <literal>...</literal> do zmiennej ilości argumentów</title>
       <programlisting role="php">
<![CDATA[
<?php
function suma(...$liczby) {
    $wynik = 0;
    foreach ($liczby as $liczba) {
        $wynik += $liczba;
    }
    return $wynik;
}

echo suma(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>

     <para>
      Możesz także użyć <literal>...</literal> podczas wywoływania funkcji, aby rozpakować
      zmienną tablicową lub <classname>Traversable</classname>, albo literal
      do listy argumentów:

      <example>
       <title>Użycie <literal>...</literal> do dostarczenia argumentów</title>
       <programlisting role="php">
<![CDATA[
<?php
function dodaj($a, $b) {
    return $a + $b;
}

echo dodaj(...[1, 2])."\n";

$a = [1, 2];
echo dodaj(...$a);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3
3
]]>
       </screen>
      </example>
     </para>

     <para>
      Możesz określić normalne argumenty pozycyjne przed tokenem
      <literal>...</literal>. W tym wypadku tylko końcowe argumenty,
      które nie pasują do żadnego argumentu pozycyjnego, zostaną dodane do tablicy
      generowanej przez <literal>...</literal>.
     </para>

     <para>
      Jest także możliwe
      <link linkend="language.oop5.typehinting">wskazanie typu</link> przez tokenem
      <literal>...</literal>. Jeżeli jest to obecne, to wszystkie argumenty
      pokrywane przez <literal>...</literal> muszą być obiektami wskazanej klasy.

      <example>
       <title>Różna ilość argumentów z określeniem typu</title>
       <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' dni';

// Jest to błędem, ponieważ null nie jest obiektem klasy DateInterval.
echo total_intervals('d', null);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3 dni
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
       </screen>
      </example>
     </para>

     <para>
      W końcu, możesz podać także różną ilość argumentów
      <link linkend="functions.arguments.by-reference">przez referencję</link>
      prefiksując <literal>...</literal> znakiem ampersand
      (<literal>&amp;</literal>).
     </para>
    </sect3>

    <sect3 xml:id="functions.variable-arg-list.old">
     <title>Starsze wersje PHP</title>

     <para>
      Do określenia, że funkcja przyjmuje zmienną ilość argumentów, nie jest wymagana specjalna składnia;
      jednak uzyskanie dostępu do argumentów funkcji wymaga użycia
      <function>func_num_args</function>, <function>func_get_arg</function>
      i <function>func_get_args</function>.
     </para>

     <para>
      Pierwszy przykład podany wyżej, w wersji PHP 5.5 i starszych,
      zostałby zapisany następująco

      <example>
       <title>Dostęp do zmiennej ilości argumentów w PHP 5.5 i starszych</title>
       <programlisting role="php">
<![CDATA[
<?php
function suma() {
    $wynik = 0;
    foreach (func_get_args() as $liczba) {
        $wynik += $liczba;
    }
    return $wynik;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>
    </sect3>

   </sect2>

  </sect1>
 
  <sect1 xml:id="functions.returning-values">
   <title>Zwracanie wartości</title>
 
   <para>
    Wartości zwracane są przy użyciu opcjonalnego wyrażenia return. Wszystkie
    typy mogą być zwracane, łącznie z tablicami i obiektami. Powoduje to natychmiastowe
    zakończenie wykonywania funkcji i wznowienie wykonywania skryptu od linijki w której
    funkcja została wywołana. Zobacz <function>return</function>
    aby uzyskać więcej informacji.
   </para>

   <note>
    <para>
     Jeżeli <function>return</function> zostanie pominięte, zwrócona będzie
     wartość &null;,
    </para>
   </note>

   <sect2>
    <title>Użycie return</title>
   <para>
    <example>
     <title>Użycie <function>return</function></title>
     <programlisting role="php">
<![CDATA[
<?php
function kwadrat($liczba)
{
    return $liczba * $liczba;
}
echo kwadrat(4);   // wypisuje '16'.
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Funkcja nie może zwracać wielu wartości, ale podobny efekt
    może zostać osiągnięty poprzez zwracanie tablicy.
   </para>
   <para>
    <example>
     <title>Zwracanie tablicy</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Aby zwrócić referencję, użyj operatora &amp; zarówno
    w deklaracji funkcji jak i podczas przypisywania zwracanej wartości
    zmiennej:
   </para>
   <para>
    <example>
     <title>Zwracanie referencji</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    Aby uzyskać więcej informacji o referencjach, przejdź do <link
    linkend="language.references">Wyjaśnienie Referencji</link>.
   </simpara>
   </sect2>
   
  <sect2 xml:id="functions.returning-values.type-declaration">
   <title>Deklaracje typu zwracanej wartości</title>

   <para>
    PHP 7 dodaje wsparcie dla deklaracji zwracanych typów. Podobnie do
    <link linkend="functions.arguments.type-declaration">deklaracji typów argumentów</link>,
    deklaracje zwracanych typów określają typ wartości, który zostanie zwrócony
    Przez funkcję. Dostępne są te same
    <link linkend="functions.arguments.type-declaration.types">typy</link>
    deklaracji, jak dla deklaracji typu argumetów.
   </para>

   <para>
    <link linkend="functions.arguments.type-declaration.strict">Ścisłe typowanie</link>
    wpływa także na deklaracje zwracanego typu. W domyślnym, słabym (luźnym) trybie,
    zwracana wartość może być przekształcona do oczekiwanego typu. W trybie
    ścisłym zwracana wartość musi być dokładnie oczekiwanego typu, w przeciwnym
    wypadku zostanie rzucony wyjątek <classname>TypeError</classname>.
   </para>

   <para>
    Od PHP 7.1.0 zwracane wartości mogą być oznaczone jako nullowalne poprzez
    poprzedzenie nazwy typu znakiem zapytania (<literal>?</literal>). Oznacza to,
    że funkcja zwraca podany typ lub &null;.
   </para>

   <note>
    <para>
     Podczas nadpisywania metody nadrzędnej, metoda potomka musi mieć zwracany typ
     zgodny ze swoim rodzicem. Jeżeli rodzic nie określa zwracanego typu, to metoda
     potomna może to zrobić.
    </para>
   </note>

   <sect3 xml:id="functions.returning-values.type-declaration.examples">
    &reftitle.examples;

    <example>
     <title>Podstawowa deklaracja zwracanego typu</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum($a, $b): float {
    return $a + $b;
}

// Zwauważ że zwrócona będzie wartość typu float.
var_dump(sum(1, 2));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
float(3)
]]>
      </screen>
     </example>

     <example>
      <title>Tryb ścisły w akcji</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
]]>
      </screen>
     </example>

     <example>
      <title>Zwracanie obiektu</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
]]>
      </screen>
     </example>
     <example>
      <title>Deklaracja zwracanego typu akceptująca &null; (od PHP 7.1.0)</title>
      <programlisting role="php">
<![CDATA[
<?php
function get_item(): ?string {
    if (isset($_GET['item'])) {
        return $_GET['item'];
    } else {
        return null;
    }
}
?>
]]>
      </programlisting>
     </example>
    </sect3>
   </sect2>
  </sect1>
 
  <sect1 xml:id="functions.variable-functions">
   <title>Funkcje zmiennych</title>

   <para>
    PHP obsługuje opcję funkcji zmiennych. Oznacza to, że jeśli
    do nazwy zmiennej dodane są nawiasy, PHP postara się znaleźć
    funkcję o nazwie takiej jak wartość zmiennej
    i spróbuje ją wykonać. Między innymi, może to służyć do
    zaimplementowania tzw. callbacks, tablic funkcji, a także wielu innych rzeczy.
   </para>
   <para>
    Funkcje zmiennych nie zadziałają z takimi elementami języka
    jak <function>echo</function>, <function>print</function>,
    <function>unset</function>, <function>isset</function>,
    <function>empty</function>, <function>include</function>,
    <function>require</function> i podobnymi. Używaj okrężnych funkcji
    aby skorzystać z któregoś z powyższych elementów języka jako funkcji zmiennych.
   </para>
   <para>
    <example>
     <title>Przykład funkcji zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "W foo()<br />\n";
}

function bar($arg = '')
{
    echo "W bar(); argumentem było '$arg'.<br />\n";
}

// To jest funkcja okrężna dla "echo"
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // Wywołuje foo()

$func = 'bar';
$func('test');  // Wywołuje bar()

$func = 'echoit';
$func('test');  // Wywołuje echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Jako funkcje zmiennych mogą być także wywoływane metody obiektów.
    <example>
     <title>Przykład metod zmiennych</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Zmienna()
    {
        $name = 'Bar';
        $this->$name(); // Wywołuje metodę Bar()
    }
    
    function Bar()
    {
        echo "To jest Bar";
    }
}

$foo = new Foo();
$funcname = "Zmienna";
$foo->$funcname();  // Wywołuje $foo->Zmienna()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Gdy wywołuje się metody statyczne, wywołanie funkcji jest mocniejsze niż operator własności statycznej:
    <example>
     <title>Przykład zmiennej metody z właściwościami statycznymi</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $zmienna = 'własność statyczna';
    static function Zmienna()
    {
        echo 'Wywołano metodę Zmienna';
    }
}

echo Foo::$zmienna; // Wyświetli 'własność statyczna'. Potrzebna jest $zmienna w tym zasięgu.
$zmienna = "Zmienna";
Foo::$variable();  // Wywoła $foo->Zmienna() odczytując $zmienna w tym zasięgu.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
     Od PHP 5.4.0 możesz wywołać dowolną wartość typu <type>callable</type> trzymaną w zmiennej.
    <example>
     <title>Kompleksowy przykład callables</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // wyświetli "bar"
$func = array(new Foo, "baz");
$func(); // wyświetli "baz"
$func = "Foo::bar";
$func(); // wyświetli "bar" od PHP 7.0.0; wcześniej wygeneruje fatal error
?>
]]>
     </programlisting>
    </example>
   </para>
      
   <para>
    Zobacz także <function>is_callable</function>, <function>call_user_func</function>,
    <link linkend="language.variables.variable">
    zmienne zmienne</link> oraz <function>function_exists</function>.
   </para>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.0.0</entry>
         <entry>
          'NazwaKlasy::nazwaMetody' jest dozwoloną fukcją zmienną.
         </entry>
        </row>
        <row>
         <entry>5.4.0</entry>
         <entry>
          Tablice, które są poprawnymi callables, są dozwolone jako zmienne funkcje.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>
  </sect1>
  
  <sect1 xml:id="functions.internal">
   <title>Wewnętrzne (wbudowane) funkcje</title>
   
   <para>
    PHP zapewnia wiele wbudowanych funkcji i konstrukcji. Istnieją także
    funkcje wymagające wkompilowania specyficznych rozszerzeń PHP, w przeciwnym wypadku
    wywołanie ich skutkuje błędami "undefined function". Na przykładd, aby użyć funkcji
    <link linkend="ref.image">obrazków</link> takich jak
    <function>imagecreatetruecolor</function>, PHP musi być skompilowane z obsługą
    <productname>GD</productname>. Aby użyć
    <function>mysqli_connect</function>, PHP musi być skompilowane z obsługą
    <link linkend="ref.mysqli">MySQLi</link>. Jest wiele funkcji wbudowanych
    w rdzeń każdej wersji PHP, takich jak funkcje
    <link linkend="ref.strings">typu string</link> oraz 
    <link linkend="ref.var">zmiennych</link>. Wywołanie
    to <function>phpinfo</function> lub
    <function>get_loaded_extensions</function> pokaże, które rozszerzenia
    PHP są załadowane. Zauważ, że wiele rozszerzeń jest domyślnie załadowanych i 
    podręcznik PHP jest podzielony według rozszerzeń. Zobacz rozdziały o 
    <link linkend="configuration">konfiguracji</link>,
    <link linkend="install">instalacji</link>, a także te dotyczące
    poszczególnych rozszerzeń, aby dowiedzieć się jak uruchomić PHP.
   </para>
   <para>
    Czytanie i rozumienie prototypów funkcji wyjaśnione jest w rozdziale
    podręcznika zatytułowanym <link linkend="about.prototypes">jak czytać
    definicje funkcji</link>. Ważne jest zrozumienie, czy funkcja zwraca konkretną wartość
    czy operuje bezpośrednio na podanej zmiennej. Na przykład,
    <function>str_replace</function> zwróci zmodyfikowany obiekt typu string, podczas gdy
    <function>usort</function> pracuje bezpośrednio na podanej zmiennej.
    Każda funkcja posiada swoją stronę w podręczniku PHP, która podaje informacje takie jak
    parametry funkcji, jej zachowanie, wartości zwracane po poprawnym wykonaniu i w przypadku błędu,
    a także dane dotyczące jej dostępności.
    Znanie tych ważnych (chociaż często drobnych) różnic jest kluczowe podczas
    pisania kodu w PHP.
   </para>
   <note>
    <simpara>
     Jeśli parametry podane funkcji nie są takie, jak spodziewane, na przykład 
     tablica(<type>array</type>) podawana jest w miejscu, gdzie oczekiwana jest zmienna typu <type>string</type>, 
     wartość zwracana przez funkcję nie jest zdefiniowana. W takim wypadku funkcja prawdopodobnie
     zwróci &null; ale jest to jedynie konwencja
     a nie zasada, na której można się opierać.
    </simpara>
   </note>
   <para>
    Zobacz także <function>function_exists</function>, 
    <link linkend="funcref">the function reference</link>,
    <function>get_extension_funcs</function> i 
    <function>dl</function>.
   </para>
   
  </sect1>
  
  <sect1 xml:id="functions.anonymous">
   <title>Funkcje anonimowe</title>

   <simpara>
    Funkcje anonimowe, znane także jako <literal>closures</literal> (pol. domknięcia), pozwalają
    pozwalają na utworzenie funkcji, które nie mają określonej nazwy. Są najbardziej użyteczne jako
    wartość parametru typu <link linkend="language.types.callback">callback</link>,
    ale mają też wiele innych zastosowań.
   </simpara>
   <simpara>
    Funkcje anonimowe są zaimplementowane przy użyciu klasy <link linkend="class.closure">Closure</link>.
   </simpara>

   <example>
    <title>Przykład funkcji anonimowej</title>
    <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// wyświetli helloWorld
?>
]]>
    </programlisting>
   </example>

   <simpara>
    Domknięcia mogą zostać użyte także jako wartości zmiennych; PHP automatycznie 
    konwertuje takie wyrażenia na instancje
    wewnętrznej klasy <classname>Closure</classname>. Przypisanie domknięcia do
    zmiennej korzysta z takiej samej składni jak każde inne przypisanie, włączając w to
    średnik na końcu:
   </simpara>

   <example>
    <title>Przypisanie funkcji anonimowej do zmiennej</title>
    <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Witaj %s\r\n", $name);
};

$greet('Świecie');
$greet('PHP');
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    Domknięcia mogą także dziedziczyć zmienne z zasięgu nadrzędnego. Każda taka
    musi być przekazana za pomocą kontrukcji <literal>use</literal>.
    Od PHP 7.1 jako takie zmienne nie mogą zostać użyte &link.superglobals;,
    <varname>$this</varname> oraz zmienne o nazwach takich jak parametry.
   </simpara>

   <example>
    <title>Dziedziczenie zmiennych z nadrzędnego zakresu</title>
    <programlisting role="php">
<![CDATA[
<?php
$message = 'hello';

// Brak "use"
$example = function () {
    var_dump($message);
};
$example();

// Odziedzicz $message
$example = function () use ($message) {
    var_dump($message);
};
$example();

// Wartość jest dziedziczona podczas definiowania funkcji,
// a nie jej wykonywania
$message = 'world';
$example();

// Zresetuj wiadomosć
$message = 'hello';

// Odziedzicz przez referencje
$example = function () use (&$message) {
    var_dump($message);
};
$example();

// Zmieniona wartość w zasięgu nadrzędnym jest
// brana pod uwagę wewnątrz wywołania funkcji
$message = 'world';
$example();

// Domknięcia mogą także przyjmować normalne argumenty
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hello");
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "hello"
string(5) "hello"
string(5) "hello"
string(5) "world"
string(11) "hello world"
]]>
    </screen>
   </example>

   <simpara>
    Dziedziczenie zmiennych z zasięgu nadrzędnego to <emphasis>nie</emphasis> 
    to samo co użycie zmiennych globalnych. 
    Zmienne globalne istnieją w zasięgu globalnym, który jest jednakowy
    bez względu na wykonywaną funkcję. Nadrzędnym zasięgiem domknięcia jest
    funkcja, w której domknięcie zostało zadeklarowane (niekoniecznie funkcja,
    z której zostało wykonane). Zobacz poniższy przykład:
   </simpara>

   <example>
    <title>Domknięcia i zasięg</title>
    <programlisting role="php">
<![CDATA[
<?php
// Podstawowy koszyk sklepowy, który zawiera listę dodanych produktów
// i ilość każdego z nich. Zawiera metodę, która
// liczy całkowitą cenę produktów w koszyku używając
// funkcji anonimowej jako callbacku.
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);
    }
}

$my_cart = new Cart;

// Dodaj produkty do koszyka
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// Wyświetl całkowitą cenę z 5% podatkiem.
print $my_cart->getTotal(0.05) . "\n";
// Wynik to 54.29
?>
]]>
    </programlisting>
   </example>
   
   <example>
    <title>Automatyczne przypisanie <literal>$this</literal></title>
    <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();
    
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
    </screen>
    &example.outputs.53;
    <screen>
<![CDATA[
Notice: Undefined variable: this in script.php on line 8
NULL]]>
    </screen>
   </example>

   <para>
    Od PHP 5.4.0, gdy funkcja anonimowa jest zadeklarowana w kontekście klasy,
    obecna klasa jest automatycznie do niej przypisywana, sprawiając że w zakresie
    funkcji jest dostępna zmienna <literal>$this</literal>. Jeśli to automatyczne
    powiązywanie jest niepożądane, można w zamian użyć
    <link linkend="functions.anonymous-functions.static">statycznych funkcji
    anonimowych</link>.
   </para>

   <sect2 xml:id="functions.anonymous-functions.static">
    <title>Statyczne funkcje anonimowe</title>
    <para>
     Od PHP 5.4 funkcje anonimowe mogą być zadeklarowane jako statyczne.
     Zapobiega to przed automatycznym przypisaniem do nich obecnej klasy.
     Nie można też przypisać do nich obiektów w czasie wykonywania skryptu.
    </para>
    <para>
     <example>
      <title>Próba użycia <literal>$this</literal> wewnątrz statycznej funkcji anonimowej</title>
      <programlisting role="php">
<![CDATA[
<?php

class Foo {
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>Próba przypisania obiektu do statycznej funkcji anonimowej</title>
      <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // ciało funkcji
};
$func = $func->bindTo(new StdClass);
$func();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
      </screen>
     </example>
    </para>
   </sect2>

   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.1.0</entry>
         <entry>
          Funkcje anonimowe nie mogą używać &link.superglobals;,
          <varname>$this</varname> oraz zmiennych o nazwach takich
          jak parametry.
         </entry>
        </row>
        <row>
         <entry>5.4.0</entry>
         <entry>
          Funkcje anonimowe mogą używać <varname>$this</varname> i być zadeklarowane
          statycznie.
         </entry>
        </row>
        <row>
         <entry>5.3.0</entry>
         <entry>
          Funkcje anonimowe stały się dostępne.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      Jest możliwe użycie <function>func_num_args</function>,
      <function>func_get_arg</function> i <function>func_get_args</function>
      z poziomu funkcji anonimowej.
     </simpara>
    </note>
   </sect2>

  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
