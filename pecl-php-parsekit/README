parsekit: PHP Opcode Analyser

Provides a userspace interpretation of the opcodes 
generated by the Zend engine compiler built into PHP.

This extension is meant for development and debug 
purposes only and contains some code which is 
potentially non-threadsafe.

This extension exports two functions 
(parsekit_compile_string(string phpcode[, array &errors]) 
and parsekit_compile_file(string filename[, array &errors])) 
which will attempt to compile one or more blocks of PHP 
code into Zend opcodes.  

The output of these functions is an n-depth hash containing 
the main block of code's oparray at its root, with 
function_table and class_table elements to hold any functions 
or classes declared within the compiled code.

In order to accomplish these compilation steps within 
the context of an active execution, some potentially unsafe
methods are used.

1) Compilation modifies EG(function_table) and EG(class_table),
   after compilation completes, parsekit pops these functions
   and classes off the end of these stacks.

2) To avoid parse errors in supplied code causing a zend_bailout(),
   parsekit replaces zend_error_cb with a wrapper which passes E_CORE_ERROR
   or any error which occurs outside of parsekit_compile_*() onto
   the original zend_error_cb.  If another module which replaced
   zend_error_cb were to be loaded prior to parsekit, then unloaded
   after parsekit's startup, but prior to parsekit's shutdown, then
   the global value zend_error_cb could become populated with an
   invalid function pointer.

The moral of the story:  Use this at your own risk.

This extension also exports constant entries for all class types,
function types, node types, and opcodes.  While a name collision
would be unexpected, all constants are prefixed with PARSEKIT_
just to be safe.

Example:

#define ZEND_NOP	0

Exported as:

REGISTER_LONG_CONSTANT("PARSEKIT_ZEND_NOP",	0, CONST_CS | CONST_PERSISTENT);

For examples on usage, refer to the examples subdirectory in this package.
