<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 351133 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<refentry xml:id="function.usort" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>usort</refname>
  <refpurpose>Trie un tableau en utilisant une fonction de comparaison</refpurpose>
 </refnamediv>
 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>bool</type><methodname>usort</methodname>
   <methodparam><type>array</type><parameter role="reference">array</parameter></methodparam>
   <methodparam><type>callable</type><parameter>value_compare_func</parameter></methodparam>
  </methodsynopsis>
  <para>
   <function>usort</function> va trier le tableau <parameter>array</parameter>
   avec ses valeurs, en utilisant une fonction définie par l'utilisateur.
   Si un tableau doit être trié avec un critère complexe, il est préférable
   d'utiliser cette fonction.
  </para>
  &note.sort-unstable;
  &note.no-key-association;
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>array</parameter></term>
     <listitem>
      <para>
       Le tableau d'entrée.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>value_compare_func</parameter></term>
     <listitem>
      <para>
       &return.callbacksort;
      </para>
      &callback.cmp;
      <caution>
       <para>
        Le fait de retourner des valeurs <emphasis>non entières</emphasis>
        depuis la fonction de comparaison, comme des valeurs de type &float;
        fera que l'intervalle sera transtypé en &integer; en se basant sur
        la valeur retournée par la fonction de rappel. Aussi des valeurs comme
        0.99 et 0.1 sera toutes les deux transformées en la valeur 0, et leur
        comparaison sera égale.
       </para>
      </caution>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   &return.success;
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example xml:id="function.usort.examples.basic">
    <title>Exemple avec <function>usort</function></title>
    <programlisting role="php">
<![CDATA[
<?php
function cmp($a, $b)
{
    if ($a == $b) {
        return 0;
    }
    return ($a < $b) ? -1 : 1;
}

$a = array(3, 2, 5, 6, 1);

usort($a, "cmp");

foreach ($a as $key => $value) {
    echo "$key: $value\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
0: 1
1: 2
2: 3
3: 5
4: 6
]]>
    </screen>
   </example>
  </para>
  <note>
   <para>
    Évidemment dans ce cas trivial, <function>sort</function> serait plus
    approprié.
   </para>
  </note>
  <para>
   <example xml:id="function.usort.examples.multi">
    <title>
     Tri avec <function>usort</function> sur un tableau multidimensionnel
    </title>
    <programlisting role="php">
<![CDATA[
<?php
function cmp($a, $b)
{
    return strcmp($a["fruit"], $b["fruit"]);
}

$fruits[0]["fruit"] = "lemons";
$fruits[1]["fruit"] = "apples";
$fruits[2]["fruit"] = "grapes";

usort($fruits, "cmp");

while (list($key, $value) = each($fruits)) {
    echo "\$fruits[$key]: " . $value["fruit"] . "\n";
}
?>
]]>
    </programlisting>
    <para>
     Lors du tri de tableau multidimensionnel, <varname>$a</varname> et
     <varname>$b</varname> contiennent des références sur le premier
     élément du tableau.
    </para>
    &example.outputs;
    <screen>
<![CDATA[
$fruits[0]: apples
$fruits[1]: grapes
$fruits[2]: lemons
]]>
    </screen>
   </example>
  </para>
  <para>
   <example xml:id="function.usort.examples.object">
    <title>
     Tri avec <function>usort</function> sur un objet
    </title>
    <programlisting role="php">
<![CDATA[
<?php
class TestObj {
    var $name;

    function TestObj($name)
    {
        $this->name = $name;
    }

    /* Ceci est une fonction de comparaison statique */
    static function cmp_obj($a, $b)
    {
        $al = strtolower($a->name);
        $bl = strtolower($b->name);
        if ($al == $bl) {
            return 0;
        }
        return ($al > $bl) ? +1 : -1;
    }
}

$a[] = new TestObj("c");
$a[] = new TestObj("b");
$a[] = new TestObj("d");

usort($a, array("TestObj", "cmp_obj"));

foreach ($a as $item) {
    echo $item->name . "\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
b
c
d
]]>
    </screen>
   </example>
   <example xml:id="function.usort.examples.closure">
    <title>
     Exemple avec <function>usort</function> en utilisant
     une <link linkend="functions.anonymous">closure</link>
     pour trier un tableau multi-dimensionnel
    </title>
    <programlisting role="php">
<![CDATA[
<?php
$array[0] = array('key_a' => 'z', 'key_b' => 'c');
$array[1] = array('key_a' => 'x', 'key_b' => 'b');
$array[2] = array('key_a' => 'y', 'key_b' => 'a');

function build_sorter($key) {
    return function ($a, $b) use ($key) {
        return strnatcmp($a[$key], $b[$key]);
    };
}

usort($array, build_sorter('key_b'));

foreach ($array as $item) {
    echo $item['key_a'] . ', ' . $item['key_b'] . "\n";
}
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
y, a
x, b
z, c
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>uasort</function></member>
    <member>&seealso.array.sorting;</member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
