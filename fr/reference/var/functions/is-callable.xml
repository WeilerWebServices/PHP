<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- EN-Revision: 350580 Maintainer: yannick Status: ready -->
<!-- Reviewed: yes -->

<refentry xml:id="function.is-callable" xmlns="http://docbook.org/ns/docbook">
 <refnamediv>
  <refname>is_callable</refname>
  <refpurpose>Détermine si l'argument peut être appelé comme fonction</refpurpose>
 </refnamediv>

 <refsect1 role="description">
  &reftitle.description;
  <methodsynopsis>
   <type>bool</type><methodname>is_callable</methodname>
   <methodparam><type>mixed</type><parameter>var</parameter></methodparam>
   <methodparam choice="opt"><type>bool</type><parameter>syntax_only</parameter><initializer>&false;</initializer></methodparam>
   <methodparam choice="opt"><type>string</type><parameter role="reference">callable_name</parameter></methodparam>
  </methodsynopsis>
  <para>
   Vérifie qu'une variable est un <type>callable</type>.
  </para>
 </refsect1>

 <refsect1 role="parameters">
  &reftitle.parameters;
  <para>
   <variablelist>
    <varlistentry>
     <term><parameter>var</parameter></term>
     <listitem>
      <para>
       La valeur à vérifier.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>syntax_only</parameter></term>
     <listitem>
      <para>
       Si l'argument <parameter>syntax_only</parameter> vaut &true;, la
       fonction ne va vérifier que si <parameter>var</parameter> peut être
       une fonction ou une méthode. Il va simplement rejeter les variables
       qui ne sont pas des chaînes, ou des tableaux qui n'ont pas la bonne
       structure pour être utilisés comme fonction de rappel. Les tableaux
       valides sont supposés n'avoir que deux entrées, le premier étant un
       objet ou une chaîne, et le second une chaîne.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><parameter>callable_name</parameter></term>
     <listitem>
      <para>
       L'argument <parameter>callable_name</parameter> reçoit le nom
       à utiliser. Dans l'exemple ci-dessous, il vaut
       <literal>"someClass::someMethod"</literal>. Notez que, bien que
       <literal>someClass::someMethod()</literal> puisse être appelée sous forme
       statique, ce n'est pas le cas.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>
 </refsect1>

 <refsect1 role="returnvalues">
  &reftitle.returnvalues;
  <para>
   Retourne &true; si <parameter>var</parameter> peut être appelé comme
   une fonction, &false; sinon.
  </para>
 </refsect1>

 <refsect1 role="examples">
  &reftitle.examples;
  <para>
   <example>
    <title>Exemple avec <function>is_callable</function></title>
    <programlisting role="php">
<![CDATA[
<?php
//  Comment vérifier qu'une variable peut être appelée
//  comme fonction ?

//
//  Variable simple contenant une fonction
//

function someFunction()
{
}

$functionVariable = 'someFunction';

var_dump(is_callable($functionVariable, false, $callable_name));  // bool(true)

echo $callable_name, "\n";  // someFunction

//
//  Tableau contenant une méthode
//

class someClass {

  function someMethod() 
  {
  }

}

$anObject = new someClass();

$methodVariable = array($anObject, 'someMethod');

var_dump(is_callable($methodVariable, true, $callable_name));  //  bool(true)

echo $callable_name, "\n";  //  someClass::someMethod

?>
]]>
    </programlisting>
   </example>
   <example>
    <title><function>is_callable</function> et les constructeurs</title>
    <simpara>
     Depuis PHP 5.3.0, <function>is_callable</function> vérifie si un constructeur
     est appelable ou non. Ceci affecte les constructeurs style PHP 5
     (<literal>__construct</literal>) mais aussi les constructeurs style PHP 4
     (i.e. méthodes avec le même nom que la classe). Auparavant, les deux étaient considérés
     comme appelable.
    </simpara>
    <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    public function __construct() {}
    public function foo() {}
}

var_dump(
    is_callable(array('Foo', '__construct')),
    is_callable(array('Foo', 'foo'))
);
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
bool(false)
bool(false)
]]>
    </screen>
   </example>
  </para>
 </refsect1>

 <refsect1 role="seealso">
  &reftitle.seealso;
  <para>
   <simplelist>
    <member><function>function_exists</function></member>
    <member><function>method_exists</function></member>
   </simplelist>
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->